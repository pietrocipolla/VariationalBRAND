# -*- coding: utf-8 -*-
"""useful.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZvO4Den1OdMWEJ87yKss7z6MTYAIJhYk
"""
import jax
# import jax.numpy as jnp
# import jax.numpy.linalg.det as jdet
# import jax.numpy.linalg.inv as jinv
# import jax.scipy as js
# import jax.scipy.special.digamma as jdigamma
# import jax.scipy.special.gamma as jgamma

import jax.numpy as jnp
import jax.scipy as js
from jax._src.numpy.linalg import jdet, jinv
from jax._src.scipy.special import jdigamma
from jax.scipy.stats.gamma import pdf as gamma
from jax.scipy.stats.gamma import pdf as jgamma

# val atteso log beta
def E_log_beta(a,b):
    # a,b coeffs logbeta
    return jdigamma(a)-jdigamma(a+b)

# val atteso log densità normal inverse wishart 
def E_log_dens_norm_inv_wish(mu,nu,lam,psi,p):
    # p dim of mu
    ret = -jnp.log(jdet(jinv(psi)))
    for i in range(1,p+1):
        ret = ret - jdigamma((nu-i+1)/2)
    ret = ret - jnp.log(lam**p)

    em = jnp.exp(js.special.multigammaln(nu/2,p))
    ret = ret + jnp.log((jdet(psi)**(nu/2))/((2**(nu*p/2))*em))

    brut = p*jnp.log(2) + jnp.log(jdet(jinv(psi)))
    for k in range(1,p+1):
        brut = brut + jdigamma((nu-k+1)/2)
    
    ret = ret - brut*(nu+p+1)/2
    ret = ret - p*nu/2
    return ret

# val atteso log densità dirichlet 
# def E_log_dens_dir(eta,J):
#     #print(eta)
#     s_eta = jnp.sum(eta)
#     ret = 0
#     for j in range(0,J+1):
#         ret = ret + \
#               (eta[j]-1)*\
#               (jdigamma(eta[j])
#                -jdigamma(s_eta))
#     return ret

#Versione Jacopo
def E_log_dens_dir_unjitted(eta : float ,s_eta : float,J : int):
   ret = (eta-1)*(jdigamma(eta)-jdigamma(s_eta))
   return ret
E_log_dens_dir_J = jax.jit(E_log_dens_dir_unjitted)

# val atteso log densità beta 
def E_log_dens_beta(a,b):
    b = jnp.exp(jgamma(a)*jgamma(b)/jgamma(a+b))
    return (a-1)*E_log_beta(a,b) + (b-1)*E_log_beta(b,a) - jnp.log(b)

#val atteso log normale dati
def E_log_norm(data,mu,nu,lam,psi,p):
    # mu = jnp.reshape(mu, p)
    # data = jnp.reshape(data, p)
    # psi = jnp.reshape(psi, (p,p))
    ret = -jnp.log(jdet(jinv(psi)))
    for i in range(1,p+1):
        ret = ret - jdigamma((nu-i+1)/2)
    ret = ret+p/lam
    ret = ret+ nu*jnp.dot(data-mu,jnp.dot(jinv(psi),data-mu))
    ret = -0.5*ret
    #print(ret)
    return ret

